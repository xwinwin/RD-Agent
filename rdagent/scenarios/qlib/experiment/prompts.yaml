qlib_quant_background: |-
  量化投资是一种数据驱动的资产管理方法，依赖数学模型、统计技术和计算方法来分析金融市场并做出投资决策。这种方法的两个基本组成部分是因子（factors）和模型（models）。
  
  你是一家顶级华尔街对冲基金中最权威的研究员之一。我需要你的专业知识来开发新的因子和模型，以提高我们的投资收益。根据给定的上下文，我会请求你协助设计并实现因子或模型。

  {% if runtime_environment is not none %}
  ======运行时环境======
  你有以下环境来运行代码：
  {{ runtime_environment }}
  {% endif %}

qlib_factor_background: |-
  因子是量化投资中使用的一种特征或变量，帮助解释投资组合或单一资产的收益和风险。因子被投资者用来识别和利用超额收益的来源，它们是许多量化投资策略的核心。
  因子的每个数值代表某一天某只仪器（股票等）的物理量值。
  用户将根据前几天的因子值训练模型来预测接下来几天的收益。
  因子由以下部分定义：
  1. 名称：因子的名称。
  2. 描述：因子的描述。
  3. 公式：因子的公式。
  4. 变量：公式中使用的变量或函数。
  因子可能不提供上述所有信息，因为有些可能不适用。
  请特别给出因子中的所有超参数，如窗口大小、回溯期等。一个因子应该静态定义一个具有静态源数据的输出。例如，过去10天的动量和过去20天的动量应该是两个不同的因子。

  {% if runtime_environment is not none %}
  ======运行时环境======
  你有以下环境来运行代码：
  {{ runtime_environment }}
  {% endif %}

qlib_factor_interface: |-
  你的Python代码应遵循接口以更好地与用户的系统交互。你的Python代码应包含以下部分：导入部分、函数部分和主要部分。你应该写一个主函数，名称为"calculate_{function_name}"，并在"if __name__ == __main__"部分调用这个函数。不要在你的Python代码中写任何try-except块。用户将捕获异常消息并向你提供反馈。
  用户会将你的Python代码写入一个python文件，并直接使用"python {your_file_name}.py"执行该文件。你应该计算因子值并将结果保存到与你的Python文件同一目录中的名为"result.h5"的HDF5(H5)文件中。结果文件是一个包含pandas数据帧的HDF5(H5)文件。数据帧的索引是"datetime"和"instrument"，单列名称是因子名称，值是因子值。结果文件应保存在与你的Python文件同一目录中。

qlib_factor_strategy: |-
  确保对于数据处理的每一步，数据格式（包括索引）都通过注释清楚解释。
  每个转换或计算都应伴随着数据结构的详细描述，特别关注关键方面，如数据是否具有多级索引、如何访问特定的列或索引级别，以及任何影响数据形状的操作（例如，`reset_index()`、`groupby()`、`merge()`）。
  这种逐步解释将确保数据处理的清晰和准确。例如：
  1. **从多级索引开始**：  
    ```python
    # 初始DataFrame有一个包含'datetime'和'instrument'的多级索引。
    # 要访问'datetime'索引，使用df.index.get_level_values('datetime')。
    datetime_values = df.index.get_level_values('datetime')
    ```
  
  2. **如有必要重置索引**：  
    ```python
    # 重置索引以将'datetime'和'instrument'从索引移到列。
    # 此操作扁平化多索引结构。
    df = df.reset_index()
    ```
  
  3. **执行groupby操作**：  
    ```python
    # 按'datetime'和'instrument'分组以聚合数据。
    # groupby后，结果将保持'datetime'和'instrument'作为多级索引。
    df_grouped = df.groupby(['datetime', 'instrument']).sum()
    ```
  
  4. **确保一致的日期时间格式**：  
    ```python
    # 在合并之前，确保两个DataFrame中的'datetime'列格式相同。
    # 如有必要，转换为日期时间格式。
    df['datetime'] = pd.to_datetime(df['datetime'])
    other_df['datetime'] = pd.to_datetime(other_df['datetime'])
    ```
  
  5. **合并操作**：  
    ```python
    # 合并DataFrame时，确保在'datetime'和'instrument'上合并。
    # 如果这些是索引的一部分，在合并之前重置索引。
    merged_df = pd.merge(df, other_df, on=['datetime', 'instrument'], how='inner')
    ```

qlib_factor_output_format: |-
  你的输出应该是一个类似于以下示例信息的pandas数据帧：
  <class 'pandas.core.frame.DataFrame'>
  MultiIndex: 40914个条目，来自(Timestamp('2020-01-02 00:00:00'), 'SH600000')到(Timestamp('2021-12-31 00:00:00'), 'SZ300059')
  Data columns (total 1 columns):
  #   Column            Non-Null Count  Dtype  
  ---  ------            --------------  -----  
  0   你的因子名称  40914 non-null  float64
  dtypes: float64(1)
  memory usage: <ignore>
  注意：非空计数可以与条目总数不同，因为某些仪器可能在某些天没有因子值。
  `result.h5`的一种可能格式如下：
  datetime    instrument
  2020-01-02  SZ000001     -0.001796
              SZ000166      0.005780
              SZ000686      0.004228
              SZ000712      0.001298
              SZ000728      0.005330
                              ...
  2021-12-31  SZ000750      0.000000
              SZ000776      0.002459

qlib_factor_simulator: |-
  因子将被发送到Qlib（一个面向AI的量化投资平台），以根据前几天的因子值训练模型来预测接下来几天的收益。Qlib是一个面向AI的量化投资平台，旨在通过AI技术在量化投资中实现潜力、赋能和创造价值，从探索想法到实施生产。Qlib支持多种机器学习建模范式，包括监督学习、市场动态建模和强化学习（RL）。
  用户将使用Qlib自动执行以下操作：
  1. 基于因子值生成新的因子表。
  2. 训练一个模型（如LightGBM、CatBoost、LSTM或简单的PyTorch模型），根据因子值预测接下来几天的收益。
  3. 基于预测收益和策略构建投资组合。
  4. 评估投资组合的表现，包括收益、夏普比率、最大回撤等。

qlib_factor_rich_style_description : |-
  ### 研发代理-Qlib：自动化量化交易与迭代因子演化演示

  #### [概述](#_summary)

  演示展示了假设生成、知识构建和决策制定的迭代过程。它强调了金融因子如何通过持续反馈和细化而演化。

  #### [自动化研发](#_rdloops)

  - **[研究（R）](#_research)**
    - 想法和假设的迭代开发。
    - 持续学习和知识构建。

  - **[开发（D）](#_development)**
    - 因子的渐进实施和代码生成。
    - 金融因子的自动化测试和验证。

  #### [目标](#_summary)

  通过Qlib平台展示金融因子的动态演化，强调每次迭代如何增强最终金融因子的准确性和可靠性。

qlib_factor_from_report_rich_style_description : |-
  ### 研发代理-Qlib：自动化量化交易与从财务报告中提取因子演示

  #### [概述](#_summary)

  此演示展示了从财务研究报告中提取因子、实施这些因子并通过Qlib回测分析其性能的过程，不断扩展和细化因子库。

  #### [自动化研发](#_rdloops)

  - **[研究（R）](#_research)**
    - 从财务报告中迭代开发想法和假设。
    - 持续学习和知识构建。

  - **[开发（D）](#_development)**
    - 渐进式因子提取和代码生成。
    - 金融因子的自动化实施和测试。

  #### [目标](#_summary)

  <table border="1" style="width:100%; border-collapse: collapse;">
    <tr>
      <td>💡 <strong>创新 </strong></td>
      <td>从研究报告中快速提取和测试因子的工具。</td>
    </tr>
    <tr>
      <td>⚡ <strong>效率 </strong></td>
      <td>从众多报告中快速识别有价值的因子。</td>
    </tr>
    <tr>
      <td>🗃️ <strong>输出 </strong></td>
      <td>扩展和细化因子库以支持进一步研究。</td>
    </tr>
  </table>

qlib_factor_experiment_setting: |-
  | 数据集 📊 | 模型 🤖    | 因子 🌟       | 数据划分  🧮                                   |
  |---------|----------|---------------|-------------------------------------------------|
  | CSI300  | LGBModel | Alpha158 Plus | 训练: {{ train_start }} 到 {{ train_end }} <br> 验证: {{ valid_start }} 到 {{ valid_end }} <br> 测试 &nbsp;: {{ test_start }} 到 {{ test_end }} |


qlib_model_background: |-
  模型是量化投资中用于预测投资组合或单一资产收益和风险的机器学习或深度学习结构。模型被投资者用来根据历史数据和已识别的因子生成预测，它们是许多量化投资策略的核心。
  每个模型将因子作为输入并预测未来收益。通常，模型越大，性能越好。
  模型由以下部分定义：
  1. 名称：模型的名称。
  2. 描述：模型的描述。
  3. 架构：模型的详细架构，如神经网络层或树结构。
  4. 超参数：模型中使用的超参数。
  5. 训练超参数：训练过程中使用的超参数。
  6. 模型类型：模型的类型，"表格型（Tabular）"用于表格模型，"时间序列型（TimeSeries）"用于时间序列模型。
  模型应提供关于其架构和超参数的清晰详细的文档。一个模型应该静态定义一个具有固定架构和超参数的输出。

  {% if runtime_environment is not none %}
  ======运行时环境======
  你有以下环境来运行代码：
  {{ runtime_environment }}
  {% endif %}

qlib_model_interface: |-
  你的Python代码应遵循接口以更好地与用户的系统交互。
  你的代码应该包含几个部分：
  1. 导入部分：导入必要的库。
  2. 一个类是pytorch.nn.Module的子类。这个类应该有init函数和forward函数，输入一个张量并输出一个张量。
  3. 设置一个名为"model_cls"的变量为你定义的类。

  用户会将你的代码保存到一个名为"model.py"的python文件中。然后用户会在设置cwd为目录后导入model_cls：
  ```python
  from model import model_cls
  ```
  所以你的Python代码应遵循以下模式：
  ```python
  class XXXModel(torch.nn.Module):
      ...
  model_cls = XXXModel
  ```

  模型可以配置为"表格型（Tabular）"用于表格模型或"时间序列型（TimeSeries）"用于时间序列模型。对于表格模型，输入形状是(batch_size, num_features)，而对于时间序列模型，输入形状是(batch_size, num_timesteps, num_features)。在这两种情况下，模型的输出形状应该是(batch_size, 1)。
  `num_features`将根据输入数据形状直接为模型设置。
  用户将使用以下代码初始化表格模型：
  ```python
  model = model_cls(num_features=num_features)
  ```
  用户将使用以下代码初始化时间序列模型：
  ```python
  model = model_cls(num_features=num_features, num_timesteps=num_timesteps)
  ```
  不会有其他参数传递给模型，所以给其他参数一个默认值或将它们设为静态。

  不要在你的Python代码中写任何try-except块。用户会捕获异常消息并向你提供反馈。同样，不要在代码中写main函数。用户将调用model_cls中的forward方法来获取输出张量。

  请注意，你的模型应该只使用当前特征作为输入。用户会将输入张量提供给模型的forward函数。


qlib_model_output_format: |-
  你的输出应该是一个形状为(batch_size, 1)的张量。
  输出张量应保存在与你的python文件相同的目录中名为"output.pth"的文件中。
  用户将评估输出张量的形状，因此从"output.pth"读取的张量应该是8个数字。

qlib_model_simulator: |-
  模型将被发送到Qlib以训练和评估它们在预测未来收益方面的性能。假设会根据检查结果反馈进行改进。
  Qlib是一个面向AI的量化投资平台，旨在通过AI技术在量化投资中实现潜力、赋能和创造价值，从探索想法到实施生产。Qlib支持多种机器学习建模范式，包括监督学习、市场动态建模和强化学习（RL）。
  用户将使用Qlib自动执行以下任务：
  1. 生成基线因子表。
  2. 训练你类中定义的模型，根据因子值预测接下来几天的收益。
  3. 基于预测收益使用特定策略构建投资组合。
  4. 评估投资组合的表现，包括收益、IC、最大回撤等指标。
  5. 迭代增长假设，以根据性能评估和反馈实现模型改进。

qlib_model_rich_style_description: |-
  ### Qlib模型演化自动化研发演示
  
  #### [概述](#_summary)
  
  演示展示了量化金融中假设生成、知识构建和模型构建中决策制定的迭代过程。它强调了模型如何通过持续反馈和细化而演化。
  
  #### [自动化研发](#_rdloops)
  
  - **[研究（R）](#_research)**
    - 想法和假设的迭代。
    - 持续学习和知识构建。
  
  - **[开发（D）](#_development)**
    - 演化的代码生成和模型细化。
    - 模型的自动化实施和测试。
  
  #### [目标](#_summary)
  
  通过Qlib平台展示模型的动态演化，强调每次迭代如何增强最终模型的准确性和可靠性。

qlib_model_experiment_setting: |-
  | 数据集 📊 | 模型 🤖    | 因子 🌟       | 数据划分  🧮                                   |
  |---------|----------|---------------|-------------------------------------------------|
  | CSI300  | RDAgent-dev | 20个因子 (Alpha158)  | 训练: {{ train_start }} 到 {{ train_end }} <br> 验证: {{ valid_start }} 到 {{ valid_end }} <br> 测试 &nbsp;: {{ test_start }} 到 {{ test_end }} |
